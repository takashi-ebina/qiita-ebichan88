---
title: JavaエンジニアがTypeScriptに触れて違いを感じた6つのポイント
tags:
  - Java
  - JavaScript
  - TypeScript
private: false
updated_at: '2026-01-08T11:21:29+09:00'
id: 5eab2570dbed38021851
organization_url_name: works-hi
slide: false
ignorePublish: false
---
# はじめに

本記事は、JavaエンジニアがTypeScriptを扱う際に感じた違いを解説した記事です。

これまで実務や個人開発でTypeScriptに触れていましたが、Javaの感覚でコードを読み進めていくと、TypeScript特有の概念や挙動に戸惑うことがありました。

今回は個人的に気になった点を6つピックアップして解説します。
TypeScript（JavaScript）よわよわエンジニアなので、誤りあればお手柔らかにお願いします・・！

## 想定読者

- Javaエンジニア
- JavaScriptは触ったことがあるがTypeScriptは初めて

## 前提

:::note info
本記事で扱うTypeScriptとJavaのバージョンです。

- TypeScript : 5.9.3
- Java : 25

:::

## 1. 実行時（ランタイム）における型情報の有無

TypeScriptは**静的型付け言語**であり、**型注釈**を通じて型チェックを行います。
次のコードでは、`message`変数に文字列型を指定しているため、数値を代入するとエラーが発生します。

```typescript
let message: string = "Hello, TypeScript!";
message = 42; // 「型 'number' を型 'string' に割り当てることはできません。」というエラーが発生
```

ただし、TypeScriptには**トランスパイル**という概念があり、**TypeScriptのコードはJavaScriptに変換されてから実行**されます。

この変換の過程で**型情報は削除**されるため、コードを記述する際の補助として機能しますが、実行（ランタイム）時には影響を与えません。

### TypeScriptとJavaにおけるオーバーロードの仕様差異

この「実行時に型情報が存在しない」という性質は、一例として関数のオーバーロード仕様に影響を与えます。

TypeScriptは実行時に型情報が存在するJavaと異なり、**実行時に型によって処理を分岐するオーバーロードは実現できません。**

```java:Java：オーバーロードの例
void main() {
  Calculator calc = new Calculator() {
    @Override
    public void add(int a, int b) {
      IO.println("Integer addition: " + (a + b));
    }
    @Override
    public void add(String a, String b) {
      IO.println("String addition: " + (Integer.parseInt(a) + Integer.parseInt(b)));
    }
  };
  calc.add(5, 10);     // 実行結果：Integer addition: 15
  calc.add("5", "10"); // 実行結果：String addition: 15
}
// オーバーロード:int型とString型のaddメソッドを定義
interface Calculator {
  void add(int a, int b);
  void add(String a, String b);
}
```

```TypeScript:TypeScript：オーバーロードをするとエラーになる例
// 「関数の実装が重複しています。」というエラーが発生
function add (a: number, b: number): void {
    console.log("Integer addition: " + (a + b));
}
function add (a: string, b: string): void {
    console.log("String addition: " + (Number(a) + Number(b)));
}
add(5, 10)
add("5", "10")
```

### シグネチャのオーバーロードは可能

TypeScriptでは関数の「実装」をオーバーロードすることはできませんが、**「シグネチャ」（関数の引数と戻り値の型定義）をオーバーロードすることは可能です。**
その場合、関数の本体では引数の型を判定して適切な処理を行う必要があります。

```TypeScript:TypeScript：シグネチャのオーバーロード例
function add(a: number, b: number): void;
function add(a: string, b: string): void;

function add(a: number | string, b: number | string) {
  if (typeof a === "number" && typeof b === "number") {
    console.log(a + b);
  } else if (typeof a === "string" && typeof b === "string") {
    console.log(Number(a) + Number(b));
  }
}
```

### コンストラクタのオーバーロードについて

先ほど説明したオーバーロードの仕様差異は、**コンストラクタのオーバーロード**も同様です。
対応の一つとして、先ほど説明したシグネチャのオーバーロードを利用し、実装を1つにまとめる方法があります。

また下記の例のように、コンストラクタの引数に渡していない項目はデフォルト値を設定するケースであれば、**デフォルト引数（`=`）を設定する**ことでオーバーロードのような挙動を実現できます。

```java:Java：コンストラクタのオーバーロードの例
void main() {
  User user1 = new User("Alice", 30);
  User user2 = new User("Bob", 25, "Canada");
  IO.println(user1.display()); // Name: Alice, Age: 30, Birth Place: United States
  IO.println(user2.display()); // Name: Bob, Age: 25, Birth Place: Canada
}
record User(String name, int age, String birthPlace) {
  User(String name, int age) {
    this(name, age, "United States");
  }
  User(String name, int age, String birthPlace) {
    this.name = name;
    this.age = age;
    this.birthPlace = birthPlace;
  }
  String display() {
    return "Name: " + name + ", Age: " + age + ", Birth Place: " + birthPlace;
  }
}
```

```typescript:TypeScript：デフォルト引数を使ったコンストラクタの例
function main() {
  const user1 = new User("Alice", 30);
  const user2 = new User("Bob", 25, "Canada");
  console.log(user1.display());
  console.log(user2.display());
}
class User {
  readonly name: string;
  readonly age: number;
  readonly birthPlace: string;
  constructor(
    name: string,
    age: number,
    birthPlace: string = "United States"
  ) {
    this.name = name;
    this.age = age;
    this.birthPlace = birthPlace;
  }
  display(): string {
    return `Name: ${this.name}, Age: ${this.age}, Birth Place: ${this.birthPlace}`;
  }
}
main();
```

## 2. 構造的型付けと名前的型付けの違い

プログラム言語における型付けの方法は2種類に大別されます。

- **名前的型付け（Nominal Typing）**
- **構造的型付け（Structural Typing）**

Javaは**名前的型付け**を採用しており、型の互換性は名前（クラス名やインターフェース名）によって判断されます。

```java:Java：名前的型付けの例
void main() {
  Person person = new Person();
  Dog dog = person; // 型の不一致: Main.Person から Main.Dog には変換できません
}
class Person {}
class Dog {}
```

一方で、TypeScriptは**構造的型付け**を採用しており、型の互換性はオブジェクトの構造（プロパティやメソッドの形状）によって判断されます。

```typescript:TypeScript：構造的型付けの例
type Person = { name: string; age: number; };
type Dog = { name: string; age: number; };
let person: Person = { name: "Alice", age: 30 };
let dog: Dog = person; // 問題なし: 構造が一致
```

[サバイバルTypeScript](https://typescriptbook.jp/reference/values-types-variables/structural-subtyping#構造的型付けの採用理由)によると、JavaScriptの

- **ダックタイピング**
  - オブジェクトの型よりもオブジェクトの持つメソッドやプロパティが何であるかによってオブジェクトを判断するプログラミングスタイル
- **オブジェクトリテラル**
  - `{}`という記法を用いて、オブジェクトを生成する方法

という特性がTypeScriptが構造的型付けを採用した背景となっているようです。

脱線しますが、オブジェクトを生成するためにクラスを定義するJavaにとって、インスタンス化せずにオブジェクトを生成できるオブジェクトリテラルはまあまあ見慣れない概念・・。

```javascript:JavaScript：Javaと異なり、クラスを定義せずにオブジェクトを生成できる
// プロパティを指定しながらオブジェクトを生成
const person = { name: "Bob", age: 25 };
```

### 追記：TypeScriptで名前的型付けを実現する方法

構造的型付けの説明に関して、 @juner さんから[コメント](https://qiita.com/ebichan_88/items/5eab2570dbed38021851#comment-d3c4e98004ff2d7e478f)を頂きました。

TypeScriptは基本的に構造的型付けですが、名前的型付けを実現する方法あるとのことでした。

下記の通り、privateメンバーを持つクラスの場合は他のクラスと区別されるため、構造が同じでも互換性がなくなり、名前的型付けのように振る舞います。

```typescript:TypeScript：privateメンバーを持つクラスは名前的型付けのように振る舞う例
class Person {
  #id: number;
  name: string;
  age: number;
  constructor(id: number, name: string, age: number) {
    this.#id = id;
    this.name = name;
    this.age = age;
  }
}
class Dog {
  #id: number;
  name: string;
  age: number;
  constructor(id: number, name: string, age: number) {
    this.#id = id;
    this.name = name;
    this.age = age;
  }
}
let person: Person = new Person(1, "Alice", 30);
// 型 'Person' を型 'Dog' に割り当てることはできません。
// 型 'Person' のプロパティ '#id' は、型 'Dog' 内からアクセスできない別のメンバーを参照しています。
let dog: Dog = person; 
```

- [参考：名前的型付けを実現する方法](https://typescriptbook.jp/reference/values-types-variables/structural-subtyping#名前的型付けを実現する方法)

## 3. interfaceの違い

[2. 構造的型付けと名前的型付けの違い](#2-構造的型付けと名前的型付けの違い)で説明した構造的型付けを踏まえて、interfaceの違いについて解説します。
Javaのinterfaceはクラスが実装すべきメソッドのシグネチャを定義します。
implementsしたクラスはinterfaceで定義されたメソッドを実装を強制されます。

今回の例だと、`Character`インターフェースを実装するクラスは`attack`メソッドを実装する必要があります。

```java:Java：interfaceの例
interface Character {
  void attack();
}
class Mario implements Character {
  @Override
  public void attack() {
    System.out.println("ファイアーボール（赤）を実行");
  }
}
class Luigi implements Character {
  @Override
  public void attack() {
    System.out.println("ファイアーボール（緑）を実行");
  }
}
void performAttack(Character character) {
  character.attack();
}
void main() {
  Character mario = new Mario();
  Character luigi = new Luigi();
  performAttack(mario); // ファイアーボール（赤）を実行
  performAttack(luigi); // ファイアーボール（緑）を実行
}
```

TypeScriptのinterfaceも同様の実装ができます。

```typescript:TypeScript：interfaceの例
interface Character {
  attack(): void;
}
class Mario implements Character {
  attack(): void {
    console.log("ファイアーボール（赤）を実行");
  }
}
class Luigi implements Character {
  attack(): void {
    console.log("ファイアーボール（緑）を実行");
  }
}
function performAttack(character: Character) {
  character.attack();
}
const mario = new Mario();
const luigi = new Luigi();
performAttack(mario); // ファイアーボール（赤）を実行
performAttack(luigi); // ファイアーボール（緑）を実行
```

ただし、TypeScriptでもinterfaceをクラスに実装させることはできますが、interfaceと実装関係がないオブジェクトの型注釈としても利用できます。

また、構造的型付けの性質上、interfaceを明示的に実装していないオブジェクトでも、interfaceの構造に一致すれば型として扱うことができます。

```diff_typescript:TypeScript：interfaceの柔軟な利用例
interface Character {
  attack(): void;
}
class Mario implements Character {
  attack(): void {
    console.log("ファイアーボール（赤）を実行");
  }
}
-class Luigi implements Character {
-  attack(): void {
-    console.log("ファイアーボール（緑）を実行");
-  }
-}
+const fakeMario: Character = {
+  attack() {
+    console.log("なんちゃってマリオ");
+  }
+};
function performAttack(character: Character) {
  character.attack();
}
const mario = new Mario();
-const luigi = new Luigi();
performAttack(mario); // ファイアーボール（赤）を実行
-performAttack(luigi); // ファイアーボール（緑）を実行
+performAttack(fakeMario); // なんちゃってマリオ
```

### TypeScriptのinterfaceとtypeの違い

TypeScriptには`interface`に加えて`type`も存在します。
先ほどのコードを`type`で書き換えても同様に動作します。

```typescript:TypeScript：typeの例
type Character = {
  attack(): void;
}
class Mario implements Character {
  attack(): void {
    console.log("ファイアーボール（赤）を実行");
  }
}
const fakeMario: Character = {
  attack() {
    console.log("なんちゃってマリオ");
  }
};
function performAttack(character: Character) {
  character.attack();
}
const mario = new Mario();
performAttack(mario); // ファイアーボール（赤）を実行
performAttack(fakeMario); // なんちゃってマリオ
```

`interface`はオブジェクト型を定義するために使用され、`type`は任意の型に対して別名を付けるために使用されます。

正直使い分けが良くわかっていなかったのですが、[プロを目指す人のためのTypeScript入門 安全なコードの書き方から高度な型の使い方まで](https://gihyo.jp/book/2022/978-4-297-12747-3/)によると、

>ほとんどの場合、interface宣言はtype文で代用可能です。しかもtype文のほうがより多くの場面で使えるので、interface宣言は利用せずにtype文のみ使うという流儀もあるそうです（筆者もそうです）。[^1]

[^1]: 鈴木 僚太, 『プロを目指す人のためのTypeScript入門 安全なコードの書き方から高度な型の使い方まで』(技術評論社, 2022)　89.

と記述されているので、基本的には`type`だけで十分なケースも多そうです。
が、自分はあまり詳しくないので参考程度で・・。

ここはもうちょっと勉強します・・。

- [参考記事：TypeScriptのInterfaceとTypeの比較](https://qiita.com/tkrkt/items/d01b96363e58a7df830e)

## 4. null / undefined の扱い

Javaで`null`を扱う場合、`NullPointerException`を避けるために`Optional`を使用することが一般的です。

下記の例では、`Optional<User>`を返却する`findUser`メソッドがIDに紐づいたUserを見つけることができません。
そのため、`User::display`は実行されず、`orElse`が実行され、`User not found`が出力されます。

```java:Java：Optionalを使ったnull安全の例
void main() {
  // findUser(3)でUserが見つからないため、orElseが実行される
  IO.println(findUser(3).map(User::display).orElse("User not found"));
}
Optional<User> findUser(int id) {
  Map<Integer, User> userMap =
      Map.ofEntries(Map.entry(1, new User("Alice", 30)), Map.entry(2, new User("Bob", 25)));
  return Optional.ofNullable(userMap.get(id));
}
record User(String name, int age) {
  String display() {
    return "Name: " + name + ", Age: " + age;
  }
}
```

TypeScriptでは`strictNullChecks`オプションを利用することで、コンパイルの段階で`null`や`undefined`の扱いを厳密にチェックすることができます。

下記の例では、`findUser(3)?.display()`の`findUser`関数が`undefined`を返す可能性があります。
`strictNullChecks`が有効な場合、`undefined`の可能性があるとコンパイル時にエラーが発生します。

オプショナルチェーン演算子（`?.`）を使用することで、`undefined`の場合でもエラーとならず、`undefined`のまま処理が進みます。

`undefined`の場合、`??`演算子により`"User not found"`が出力されます。

```typescript:TypeScript：null / undefined 安全の例
function main() {
  // strictNullChecks により、オプショナルチェーン演算子（?.）なしではコンパイルエラー
  console.log(findUser(3)?.display() ?? "User not found");
}
function findUser(id: number): User | undefined {
  const userMap: Record<number, User> = {
    1: {
      name: "Alice", age: 30,
      display() {
        return `Name: ${this.name}, Age: ${this.age}`;
      },
    },
    2: {
      name: "Bob", age: 25,
      display() {
        return `Name: ${this.name}, Age: ${this.age}`;
      },
    },
  };
  return userMap[id];
}
type User = {
  name: string;
  age: number;
  display(): string;
};
main();
```

オプショナルチェーン演算子（`?.`）やNull合体演算子（`??`）を使用しない場合、下記のようにコンパイルエラーが発生します。

```diff_typescript:下記の場合はコンパイルエラー
+  // 「オブジェクトは 'undefined' である可能性があります。」というエラーが発生
+  console.log(findUser(3).display())
-  // strictNullChecks により、存在チェックなしではコンパイルエラー
-  console.log(findUser(3)?.display() ?? "User not found");
```

Javaでは`Optional`を利用することで`NullPointerException`を防ぎつつ、すっきりとしたコードを書くことができます。
ただし、意識的に`Optional`や`null`チェックを行わないと、実行時に`NullPointerException`が発生する可能性があります。

一方で、TypeScriptではコンパイル時に`null`や`undefined`の扱いを厳密にチェックできます。
これにより、実行時のエラーを未然に防ぐことができます。

TypeScriptを実装していると`'undefined' の可能性があります。`のエラーが出ることが多く煩わしく感じることもありますが、実行時エラーを防ぐためには有効な手段だと理解しています。

また、オプショナルチェーン演算子（`?.`）やNull合体演算子（`??`）[^2]はJavaエンジニアにとっては見慣れない構文ですが、シンプルで便利な機能だなと思いました。

[^2]: 正確にはTypeScript独自の機能ではなく、JavaScriptの一部です。

## 5. union 型

union型は複数の型を受容する型の定義方法です。
`|`を用いて複数の型を組み合わせます。

```typescript:TypeScript：union型の例
type Result = Success | Failure;

function handle(r: Result) {
  if (r.kind === "success") {
    r.data; // 型が絞られる
  }
}
```

Javaと違って器用なことができるなと感じます。Javaに置き換えるなら、`sealed`クラスと`record`の組み合わせが近い？

```java:Java：union型の例に近い sealed クラスと record の例
sealed interface Result permits Success, Failure {}
record Success(String data) implements Result {}
record Failure(String error) implements Result {}
```

## 6. switch のパターンマッチング

switch文はJavascriptにもありますが・・。
Javaに慣れていると、Javaのswitch式を利用したパターンマッチングはやはり便利だなと感じます。

```typescript:TypeScript
function main() {
  handle({ kind: "success", data: "Operation completed successfully." });
}
type Result = Success | Failure;
type Success = {
  kind: "success";
  data: string;
};
type Failure = {
  kind: "failure";
  error: string;
};
function handle(r: Result) {
  switch (r.kind) {
    case "success":
      console.log(r.data);
      break;
    case "failure":
      console.log(r.error);
      break;
  }
}
main();
```

```java:Java
void main() {
  handle(new Success("Operation completed successfully."));
}
sealed interface Result permits Success, Failure {}
record Success(String data) implements Result {}
record Failure(String error) implements Result {}
void handle(Result r) {
  switch (r) {
    case Success s -> IO.println(s.data());
    case Failure f -> IO.println(f.error());
  }
}
```

## おわりに

### Javaエンジニアとして気になる、TypeScript / JavaScript 共通の言語機能

本記事では、JavaScriptにも当てはまる内容はできる限り割愛しています。
ただし、Javaエンジニアにとって見慣れない言語機能がいくつかあるので紹介します。

TypeScript / JavaScript を初めて勉強する際は、以下の内容に触れておくと理解が深まると思います。

- **スプレッド構文**
  - `{ ...foo };`のような書き方でオブジェクトをコピーして、展開できるの便利過ぎない？
    - [参考記事：JSのスプレッド構文を理解する](https://qiita.com/akisx/items/682a4283c13fe336c547)
- **コールバック関数**
  - TypeScript / JavaScript では基本中の基本と思われるが、Javaだとあまり馴染みがない
  - Javaだと関数型インタフェースを用いるが、書き方は冗長で全然別物
- **非同期処理**
  - 言わずもがな、`Promise` / `async` / `await`
    - [参考記事：Promiseの使い方、それに代わるasync/awaitの使い方](https://qiita.com/suin/items/97041d3e0691c12f4974)

## 参考文献

- [サバイバルTypeScript](https://typescriptbook.jp/)
- [Javaエンジニアが始めるTypeScript入門](https://developer.mamezou-tech.com/typescript-intro/introduction-to-typescript-for-java-engineer_index/)
- [プロを目指す人のためのTypeScript入門 安全なコードの書き方から高度な型の使い方まで](https://gihyo.jp/book/2022/978-4-297-12747-3/)
